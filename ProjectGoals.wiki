#summary Goals of Minify
#labels Phase-Requirements,Phase-Design

== 1. Be easy to implement ==

A PHP user should be able to quickly start serving JS/CSS much more optimally.

== 2. Be extensible/versatile ==

The user should be able to work Minify into an environment without modifying Minify's source. Right now this should be easy on the controller side, but the Minify class is static, which is fast, but may hinder extensibility.

== 3. Be fast as possible ==

Testing has shown that [http://mrclay.org/index.php/2008/06/03/pre-encoding-vs-mod_deflate/ pre-encoding files and the usage of type-maps on Apache can serve files 5x faster] than Minify::serve()! This means that Minify needs to adapt its strategy to maintaining builds of pre-encoded files rather than trying to serve them itself, at least on Apache. It's not clear how to set up lighttpd to behave the same, but it's worth looking into.

That said, Minify::serve() can still prove useful for people, and every once of performance should be squeezed out of it. More ab testing! At the moment my main performance concern is the number of separate files. With every serve() call we're at least including Source.php, Controller/Base.php, the controller in use, and !ConditionalGet.php. Non-conditional GETs (which will be most of them on a popular site) will also usually include the cache class(es) and Encoder.php, so that's at least 7 files executed per resource hit. None of the files are really large and opcode caches may make this not an issue at all, but it's worth keeping in mind. The current structure is obviously more maintainable/extensible, but what if integrating all those files into one (for, say, the Groups controller usage) greatly improved performance?